/* File created from flex.skl via mkskel.sh */

#include "flexdef.h"

const char *const skel[] =
{
    "/*",
    " * A lexical scanner generated by flex",
    " * vile:lexmode",
    " *",
    " * Scanner skeleton version:",
    " * @Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp @",
    " */",
    "",
    "#define FLEX_SCANNER",
    "#define YY_FLEX_MAJOR_VERSION 2",
    "#define YY_FLEX_MINOR_VERSION 5",
    "",
    "%-",
    "#include <stdio.h>",
    "%*",
    "",
    "/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */",
    "#ifdef c_plusplus",
    "#ifndef __cplusplus",
    "#define __cplusplus",
    "#endif",
    "#endif",
    "",
    "#ifdef __cplusplus",
    "",
    "#include <stdlib.h>",
    "#include <unistd.h>",
    "",
    "/* The \"const\" storage-class-modifier is valid. */",
    "#define YY_USE_CONST",
    "",
    "#else /* ! __cplusplus */",
    "",
    "#if __STDC__",
    "",
    "#define YY_USE_CONST",
    "",
    "#endif /* __STDC__ */",
    "#endif /* ! __cplusplus */",
    "",
    "#ifdef __TURBOC__",
    " #pragma warn -rch",
    " #pragma warn -use",
    "#include <io.h>",
    "#include <stdlib.h>",
    "#define YY_USE_CONST",
    "#endif",
    "",
    "#ifdef YY_USE_CONST",
    "#define yyconst const",
    "#else",
    "#define yyconst",
    "#endif",
    "",
    "/* Returned upon end-of-file. */",
    "#define YY_NULL 0",
    "",
    "/* Promotes a possibly negative, possibly signed char to an unsigned",
    " * integer for use as an array index.  If the signed char is negative,",
    " * we want to instead treat it as an 8-bit unsigned char, hence the",
    " * double cast.",
    " */",
    "#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)",
    "",
    "/* Enter a start condition.  This macro really ought to take a parameter,",
    " * but we do it the disgusting crufty way forced on us by the ()-less",
    " * definition of BEGIN.",
    " */",
    "#define BEGIN yy_start = 1 + 2 *",
    "",
    "/* Translate the current start state into a value that can be later handed",
    " * to BEGIN to return to the state.  The YYSTATE alias is for lex",
    " * compatibility.",
    " */",
    "#define YY_START ((yy_start - 1) / 2)",
    "#define YYSTATE YY_START",
    "",
    "/* Action number for EOF rule of a given start state. */",
    "#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)",
    "",
    "/* Special action meaning \"start processing a new file\". */",
    "#define YY_NEW_FILE yyrestart(yyin)",
    "",
    "#define YY_END_OF_BUFFER_CHAR 0",
    "",
    "/* Size of default input buffer. */",
    "#define YY_BUF_SIZE 16384",
    "",
    "typedef struct yy_buffer_state *YY_BUFFER_STATE;",
    "",
    "extern int yyleng;",
    "%-",
    "extern FILE *yyin, *yyout;",
    "%*",
    "",
    "#define EOB_ACT_CONTINUE_SCAN 0",
    "#define EOB_ACT_END_OF_FILE 1",
    "#define EOB_ACT_LAST_MATCH 2",
    "",
    "/* The funky do-while in the following #define is used to turn the definition",
    " * int a single C statement (which needs a semi-colon terminator).  This",
    " * avoids problems with code like:",
    " *",
    " * \tif (condition_holds)",
    " *\t\tyyless(5);",
    " *\telse",
    " *\t\tdo_something_else();",
    " *",
    " * Prior to using the do-while the compiler would get upset at the",
    " * \"else\" because it interpreted the \"if\" statement as being all",
    " * done when it reached the ';' after the yyless() call.",
    " */",
    "",
    "/* Return all but the first 'n' matched characters back to the input stream. */",
    "",
    "#define yyless(n) \\",
    "\t\tdo \\",
    "\t\t\t{ \\",
    "\t\t\t\t/* Undo effects of setting up yytext. */ \\",
    "\t\t\t\t*yy_cp = yy_hold_char; \\",
    "\t\t\t\tYY_RESTORE_YY_MORE_OFFSET \\",
    "\t\t\t\tyy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\",
    "\t\t\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\",
    "\t\t\t} \\",
    "\t\twhile (0)",
    "",
    "#define unput(c) yyunput(c, yytext_ptr)",
    "",
    "#ifdef YY_MALLOC_DECL",
    "YY_MALLOC_DECL",
    "#else",
    "#if __STDC__",
    "#ifndef __cplusplus",
    "#include <stdlib.h>",
    "#define YY_SIZE_T size_t",
    "#endif",
    "#else",
    "/* Just try to get by without declaring the routines.  This will fail",
    " * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)",
    " * or sizeof(void*) != sizeof(int).",
    " */",
    "#endif",
    "#endif",
    "",
    "/* The following is because we cannot portably get our hands on size_t",
    " * (without autoconf's help, which isn't available because we want",
    " * flex-generated scanners to compile on their own).",
    " */",
    "#ifndef YY_SIZE_T",
    "#define YY_SIZE_T unsigned",
    "#endif",
    "",
    "typedef YY_SIZE_T yy_size_t;",
    "",
    "struct yy_buffer_state {",
    "%-",
    "\tFILE *yy_input_file;",
    "%+",
    "\tstd::istream* yy_input_file;",
    "%*",
    "",
    "\tchar *yy_ch_buf;\t\t/* input buffer */",
    "\tchar *yy_buf_pos;\t\t/* current position in input buffer */",
    "",
    "\t/* Size of input buffer in bytes, not including room for EOB",
    "\t * characters.",
    "\t */",
    "\tyy_size_t yy_buf_size;",
    "",
    "\t/* Number of characters read into yy_ch_buf, not including EOB",
    "\t * characters.",
    "\t */",
    "\tint yy_n_chars;",
    "",
    "\t/* Whether we \"own\" the buffer - i.e., we know we created it,",
    "\t * and can realloc() it to grow it, and should free() it to",
    "\t * delete it.",
    "\t */",
    "\tint yy_is_our_buffer;",
    "",
    "\t/* Whether this is an \"interactive\" input source; if so, and",
    "\t * if we're using stdio for input, then we want to use getc()",
    "\t * instead of fread(), to make sure we stop fetching input after",
    "\t * each newline.",
    "\t */",
    "\tint yy_is_interactive;",
    "",
    "\t/* Whether we're considered to be at the beginning of a line.",
    "\t * If so, '^' rules will be active on the next match, otherwise",
    "\t * not.",
    "\t */",
    "\tint yy_at_bol;",
    "",
    "\t/* Whether to try to fill the input buffer when we reach the",
    "\t * end of it.",
    "\t */",
    "\tint yy_fill_buffer;",
    "",
    "\tint yy_buffer_status;",
    "#define YY_BUFFER_NEW 0",
    "#define YY_BUFFER_NORMAL 1",
    "\t/* When an EOF's been seen but there's still some text to process",
    "\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we",
    "\t * shouldn't try reading from the input source any more.  We might",
    "\t * still have a bunch of tokens to match, though, because of",
    "\t * possible backing-up.",
    "\t *",
    "\t * When we actually see the EOF, we change the status to \"new\"",
    "\t * (via yyrestart()), so that the user can continue scanning by",
    "\t * just pointing yyin at a new input file.",
    "\t */",
    "#define YY_BUFFER_EOF_PENDING 2",
    "};",
    "",
    "%- Standard (non-C++) definition",
    "static YY_BUFFER_STATE yy_current_buffer = 0;",
    "%*",
    "",
    "/* We provide macros for accessing buffer states in case in the",
    " * future we want to put the buffer states in a more general",
    " * \"scanner state\".",
    " */",
    "#define YY_CURRENT_BUFFER yy_current_buffer",
    "",
    "%- Standard (non-C++) definition",
    "/* yy_hold_char holds the character lost when yytext is formed. */",
    "static char yy_hold_char;",
    "",
    "static int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */",
    "",
    "int yyleng;",
    "",
    "/* Points to current character in buffer. */",
    "static char *yy_c_buf_p = (char *) 0;",
    "static int yy_init = 1;\t\t/* whether we need to initialize */",
    "static int yy_start = 0;\t/* start state number */",
    "",
    "/* Flag which is used to allow yywrap()'s to do buffer switches",
    " * instead of setting up a fresh yyin.  A bit of a hack ...",
    " */",
    "static int yy_did_buffer_switch_on_eof;",
    "",
    "void yyrestart(FILE *input_file);",
    "",
    "void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);",
    "void yy_load_buffer_state(void);",
    "YY_BUFFER_STATE yy_create_buffer(FILE *file, int size);",
    "void yy_delete_buffer(YY_BUFFER_STATE b);",
    "void yy_init_buffer(YY_BUFFER_STATE b, FILE *file);",
    "void yy_flush_buffer(YY_BUFFER_STATE b);",
    "#define YY_FLUSH_BUFFER yy_flush_buffer(yy_current_buffer)",
    "",
    "YY_BUFFER_STATE yy_scan_buffer(char *bbase, yy_size_t size);",
    "YY_BUFFER_STATE yy_scan_string(yyconst char *yy_str);",
    "YY_BUFFER_STATE yy_scan_bytes(yyconst char *bytes, int len);",
    "%*",
    "",
    "static void *yy_flex_alloc(yy_size_t);",
    "static void *yy_flex_realloc(void *, yy_size_t);",
    "static void yy_flex_free(void *);",
    "",
    "#define yy_new_buffer yy_create_buffer",
    "",
    "#define yy_set_interactive(is_interactive) \\",
    "\t\t{ \\",
    "\t\t\tif (!yy_current_buffer) \\",
    "\t\t\t\tyy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE); \\",
    "\t\t\tyy_current_buffer->yy_is_interactive = is_interactive; \\",
    "\t\t}",
    "",
    "#define yy_set_bol(at_bol) \\",
    "\t\t{ \\",
    "\t\t\tif (!yy_current_buffer) \\",
    "\t\t\t\tyy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE); \\",
    "\t\t\tyy_current_buffer->yy_at_bol = at_bol; \\",
    "\t\t}",
    "",
    "#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)",
    "",
    /*-----------------------------------------------------------------------*/
    "%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here",
    "",
    "%- Standard (non-C++) definition",
    "static yy_state_type yy_get_previous_state(void);",
    "static yy_state_type yy_try_NUL_trans(yy_state_type current_state);",
    "static int yy_get_next_buffer(void);",
    "%*",
    "",
    "/* Done after the current pattern has been matched and before the",
    " * corresponding action - sets up yytext.",
    " */",
    "#define YY_DO_BEFORE_ACTION \\",
    "\t\tyytext_ptr = yy_bp; \\",
    /*-----------------------------------------------------------------------*/
    "%% code to fiddle yytext and yyleng for yymore() goes here",
    "yy_hold_char = *yy_cp; \\",
    "*yy_cp = '\\0'; \\",
    /*-----------------------------------------------------------------------*/
    "%% code to copy yytext_ptr to yytext[] goes here, if %array",
    "\t\tyy_c_buf_p = yy_cp;",
    "",
    /*-----------------------------------------------------------------------*/
    "%% data tables for the DFA and the user's section 1 definitions go here",
    "",
    "/* Macros after this point can all be overridden by user definitions in",
    " * section 1.",
    " */",
    "",
    "#ifndef YY_SKIP_YYWRAP",
    "#ifdef __cplusplus",
    "extern \"C\" int yywrap();",
    "#else",
    "extern int yywrap(void);",
    "#endif",
    "#endif",
    "",
    "%-",
    "#ifndef YY_NO_UNPUT",
    "static void yyunput(int c, char *buf_ptr);",
    "#endif",
    "%*",
    "",
    "#ifndef yytext_ptr",
    "static void yy_flex_strncpy(char *, yyconst char *, int);",
    "#endif",
    "",
    "#ifdef YY_NEED_STRLEN",
    "static int yy_flex_strlen(yyconst char *);",
    "#endif",
    "",
    "#ifndef YY_NO_INPUT",
    "%- Standard (non-C++) definition",
    "#ifdef __cplusplus",
    "static int yyinput();",
    "#else",
    "static int input(void);",
    "#endif",
    "%*",
    "#endif",
    "",
    "#if YY_STACK_USED",
    "static int yy_start_stack_ptr = 0;",
    "static int yy_start_stack_depth = 0;",
    "static int *yy_start_stack = 0;",
    "#ifndef YY_NO_PUSH_STATE",
    "static void yy_push_state(int new_state);",
    "#endif",
    "#ifndef YY_NO_POP_STATE",
    "static void yy_pop_state(void);",
    "#endif",
    "#ifndef YY_NO_TOP_STATE",
    "static int yy_top_state(void);",
    "#endif",
    "",
    "#else",
    "#define YY_NO_PUSH_STATE 1",
    "#define YY_NO_POP_STATE 1",
    "#define YY_NO_TOP_STATE 1",
    "#endif",
    "",
    "/* Amount of stuff to slurp up with each read. */",
    "#ifndef YY_READ_BUF_SIZE",
    "#define YY_READ_BUF_SIZE 8192",
    "#endif",
    "",
    "/* workaround for defective implementation of gcc attribute warn_unused_result */",
    "#if defined(__GNUC__) && defined(_FORTIFY_SOURCE)",
    "#define YY_IGNORE_RC(func) do { if (func != 0) {} } while(0)",
    "#else",
    "#define YY_IGNORE_RC(func) (void) func",
    "#endif /* gcc workaround */",
    "",
    "/* Copy whatever the last rule matched to the standard output. */",
    "",
    "#ifndef ECHO",
    "%- Standard (non-C++) definition",
    "/* This used to be an fputs(), but since the string might contain NUL's,",
    " * we now use fwrite().",
    " */",
    "#define ECHO YY_IGNORE_RC(fwrite(yytext, (size_t) yyleng, (size_t) 1, yyout))",
    "%+ C++ definition",
    "#define ECHO LexerOutput(yytext, yyleng)",
    "%*",
    "#endif",
    "",
    "/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,",
    " * is returned in \"result\".",
    " */",
    "#ifndef YY_INPUT",
    "#define YY_INPUT(buf,result,max_size) \\",
    /*-----------------------------------------------------------------------*/
    "%% fread()/read() definition of YY_INPUT goes here unless we're doing C++",
    "%+ C++ definition",
    "\tif ((result = LexerInput((char *) buf, max_size)) < 0) \\",
    "\t\tYY_FATAL_ERROR(\"input in flex scanner failed\");",
    "%*",
    "#endif",
    "",
    "/* No semi-colon after return; correct usage is to write \"yyterminate();\" -",
    " * we don't want an extra ';' after the \"return\" because that will cause",
    " * some compilers to complain about unreachable statements.",
    " */",
    "#ifndef yyterminate",
    "#define yyterminate() return YY_NULL",
    "#endif",
    "",
    "/* Number of entries by which start-condition stack grows. */",
    "#ifndef YY_START_STACK_INCR",
    "#define YY_START_STACK_INCR 25",
    "#endif",
    "",
    "#ifndef YY_EXIT_FAILURE",
    "#define YY_EXIT_FAILURE 2",
    "#endif",
    "",
    "/* Report a fatal error. */",
    "#ifndef YY_FATAL_ERROR",
    "%-",
    "/* if the macro is defined, this function is unused */",
    "static void",
    "yy_fatal_error(yyconst char msg[])",
    "{",
    "\t(void) fprintf(stderr, \"%s\\n\", msg);",
    "\texit(YY_EXIT_FAILURE);",
    "}",
    "#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)",
    "%+",
    "#define YY_FATAL_ERROR(msg) LexerError(msg)",
    "%*",
    "#endif",
    "",
    "%+",
    "void yyFlexLexer::LexerError(yyconst char msg[])",
    "{",
    "\tstd::cerr << msg << '\\n';",
    "\texit(YY_EXIT_FAILURE);",
    "}",
    "%*",
    "",
    "/* Default declaration of generated scanner - a define so the user can",
    " * easily add parameters.",
    " */",
    "#ifndef YY_DECL",
    "%- Standard (non-C++) definition",
    "#define YY_DECL int yylex (void)",
    "%+ C++ definition",
    "#define YY_DECL int yyFlexLexer::yylex()",
    "%*",
    "#endif",
    "",
    "/* Code executed at the beginning of each rule, after yytext and yyleng",
    " * have been set up.",
    " */",
    "#ifndef YY_USER_ACTION",
    "#define YY_USER_ACTION",
    "#endif",
    "",
    "/* Code executed at the end of each rule. */",
    "#ifndef YY_BREAK",
    "#define YY_BREAK break;",
    "#endif",
    "",
    /*-----------------------------------------------------------------------*/
    "%% YY_RULE_SETUP definition goes here",
    "",
    "YY_DECL",
    "{",
    "\tyy_state_type yy_current_state;",
    "\tchar *yy_cp, *yy_bp;",
    "\tint yy_act;",
    "",
    /*-----------------------------------------------------------------------*/
    "%% user's declarations go here",
    "",
    "\tif (yy_init) {",
    "\t\tyy_init = 0;",
    "",
    "#ifdef YY_USER_INIT",
    "\t\tYY_USER_INIT;",
    "#endif",
    "",
    "\t\tif (!yy_start)",
    "\t\t\tyy_start = 1;\t/* first start state */",
    "",
    "\t\tif (!yyin)",
    "%-",
    "\t\t\tyyin = stdin;",
    "%+",
    "\t\t\tyyin = &std::cin;",
    "%*",
    "",
    "\t\tif (!yyout)",
    "%-",
    "\t\t\tyyout = stdout;",
    "%+",
    "\t\t\tyyout = &std::cout;",
    "%*",
    "",
    "\t\tif (!yy_current_buffer)",
    "\t\t\tyy_current_buffer =",
    "\t\t\t\tyy_create_buffer(yyin, YY_BUF_SIZE);",
    "",
    "\t\tyy_load_buffer_state();",
    "\t}",
    "",
    "\twhile (1) {",
    "\t\t/* loops until end-of-file is reached */",
    /*-----------------------------------------------------------------------*/
    "%% yymore()-related code goes here",
    "yy_cp = yy_c_buf_p;",
    "",
    "/* Support of yytext. */",
    "*yy_cp = yy_hold_char;",
    "",
    "/* yy_bp points to the position in yy_ch_buf of the start of",
    " * the current run.",
    " */",
    "yy_bp = yy_cp;",
    "",
    /*-----------------------------------------------------------------------*/
    "%% code to set up and find next match goes here",
    "",
    "yy_find_action:",
    /*-----------------------------------------------------------------------*/
    "%% code to find the action number goes here",
    "",
    "YY_DO_BEFORE_ACTION;",
    "",
    /*-----------------------------------------------------------------------*/
    "%% code for yylineno update goes here",
    "",
    "do_action:\t/* This label is used only to access EOF actions. */",
    /*-----------------------------------------------------------------------*/
    "%% debug code goes here",
    "",
    "switch (yy_act) {",
    "\t/* beginning of action switch */",
    /*-----------------------------------------------------------------------*/
    "%% actions go here",
    "",
    "case YY_END_OF_BUFFER:",
    "\t{",
    "\t\t/* Amount of text matched not including the EOB char. */",
    "\t\tint yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;",
    "",
    "\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */",
    "\t\t*yy_cp = yy_hold_char;",
    "\t\tYY_RESTORE_YY_MORE_OFFSET",
    "",
    "\t\tif (yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW) {",
    "\t\t\t/* We're scanning a new file or input source.  It's",
    "\t\t\t * possible that this happened because the user",
    "\t\t\t * just pointed yyin at a new source and called",
    "\t\t\t * yylex().  If so, then we have to assure",
    "\t\t\t * consistency between yy_current_buffer and our",
    "\t\t\t * globals.  Here is the right place to do so, because",
    "\t\t\t * this is the first action (other than possibly a",
    "\t\t\t * back-up) that will match for the new input source.",
    "\t\t\t */",
    "\t\t\tyy_n_chars = yy_current_buffer->yy_n_chars;",
    "\t\t\tyy_current_buffer->yy_input_file = yyin;",
    "\t\t\tyy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;",
    "\t\t}",
    "",
    "\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position",
    "\t\t * of the first EOB in the buffer, since yy_c_buf_p will",
    "\t\t * already have been incremented past the NUL character",
    "\t\t * (since all states make transitions on EOB to the",
    "\t\t * end-of-buffer state).  Contrast this with the test",
    "\t\t * in input().",
    "\t\t */",
    "\t\tif (yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars]) {",
    "\t\t\t/* This was really a NUL. */",
    "\t\t\tyy_state_type yy_next_state;",
    "",
    "\t\t\tyy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;",
    "",
    "\t\t\tyy_current_state = yy_get_previous_state();",
    "",
    "\t\t\t/* Okay, we're now positioned to make the NUL",
    "\t\t\t * transition.  We couldn't have",
    "\t\t\t * yy_get_previous_state() go ahead and do it",
    "\t\t\t * for us because it doesn't know how to deal",
    "\t\t\t * with the possibility of jamming (and we don't",
    "\t\t\t * want to build jamming into it because then it",
    "\t\t\t * will run more slowly).",
    "\t\t\t */",
    "",
    "\t\t\tyy_next_state = yy_try_NUL_trans(yy_current_state);",
    "",
    "\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;",
    "",
    "\t\t\tif (yy_next_state) {",
    "\t\t\t\t/* Consume the NUL. */",
    "\t\t\t\tyy_cp = ++yy_c_buf_p;",
    "\t\t\t\tyy_current_state = yy_next_state;",
    "\t\t\t\tgoto yy_match;",
    "\t\t\t} else {",
    /*-----------------------------------------------------------------------*/
    "%% code to do back-up for compressed tables and set up yy_cp goes here",
    "\t\t\t\t\t\tgoto yy_find_action;",
    "\t\t\t\t\t}",
    "\t\t\t\t} else {",
    "\t\t\t\t\tswitch (yy_get_next_buffer()) {",
    "\t\t\t\t\tcase EOB_ACT_END_OF_FILE:",
    "\t\t\t\t\t\t{",
    "\t\t\t\t\t\t\tyy_did_buffer_switch_on_eof = 0;",
    "",
    "\t\t\t\t\t\t\tif (yywrap()) {",
    "\t\t\t\t\t\t\t\t/* Note: because we've taken care in",
    "\t\t\t\t\t\t\t\t * yy_get_next_buffer() to have set up",
    "\t\t\t\t\t\t\t\t * yytext, we can now set up",
    "\t\t\t\t\t\t\t\t * yy_c_buf_p so that if some total",
    "\t\t\t\t\t\t\t\t * hoser (like flex itself) wants to",
    "\t\t\t\t\t\t\t\t * call the scanner after we return the",
    "\t\t\t\t\t\t\t\t * YY_NULL, it'll still work - another",
    "\t\t\t\t\t\t\t\t * YY_NULL will get returned.",
    "\t\t\t\t\t\t\t\t */",
    "\t\t\t\t\t\t\t\tyy_c_buf_p = yytext_ptr + YY_MORE_ADJ;",
    "",
    "\t\t\t\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);",
    "\t\t\t\t\t\t\t\tgoto do_action;",
    "\t\t\t\t\t\t\t} else {",
    "\t\t\t\t\t\t\t\tif (!yy_did_buffer_switch_on_eof)",
    "\t\t\t\t\t\t\t\t\tYY_NEW_FILE;",
    "\t\t\t\t\t\t\t}",
    "\t\t\t\t\t\t\tbreak;",
    "\t\t\t\t\t\t}",
    "",
    "\t\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:",
    "\t\t\t\t\t\tyy_c_buf_p =",
    "\t\t\t\t\t\t    yytext_ptr + yy_amount_of_matched_text;",
    "",
    "\t\t\t\t\t\tyy_current_state = yy_get_previous_state();",
    "",
    "\t\t\t\t\t\tyy_cp = yy_c_buf_p;",
    "\t\t\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;",
    "\t\t\t\t\t\tgoto yy_match;",
    "",
    "\t\t\t\t\tcase EOB_ACT_LAST_MATCH:",
    "\t\t\t\t\t\tyy_c_buf_p =",
    "\t\t\t\t\t\t    &yy_current_buffer->yy_ch_buf[yy_n_chars];",
    "",
    "\t\t\t\t\t\tyy_current_state = yy_get_previous_state();",
    "",
    "\t\t\t\t\t\tyy_cp = yy_c_buf_p;",
    "\t\t\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;",
    "\t\t\t\t\t\tgoto yy_find_action;",
    "\t\t\t\t\t}",
    "\t\t\t\t}",
    "\t\t\t\tbreak;",
    "\t\t\t}",
    "",
    "\t\tdefault:",
    "\t\t\tYY_FATAL_ERROR(\"fatal flex scanner internal error--no action found\");",
    "\t\t}\t\t\t/* end of action switch */",
    "\t}\t\t\t\t/* end of scanning one token */",
    "}\t\t\t\t/* end of yylex */",
    "%+",
    "yyFlexLexer::yyFlexLexer(std::istream* arg_yyin, std::ostream* arg_yyout)",
    "{",
    "\tyyin = arg_yyin;",
    "\tyyout = arg_yyout;",
    "\tyy_c_buf_p = 0;",
    "\tyy_init = 1;",
    "\tyy_start = 0;",
    "\tyy_flex_debug = 0;",
    "\tyylineno = 1;\t// this will only get updated if %option yylineno",
    "",
    "\tyy_did_buffer_switch_on_eof = 0;",
    "",
    "\tyy_looking_for_trail_begin = 0;",
    "\tyy_more_flag = 0;",
    "\tyy_more_len = 0;",
    "\tyy_more_offset = yy_prev_more_offset = 0;",
    "",
    "\tyy_start_stack_ptr = yy_start_stack_depth = 0;",
    "\tyy_start_stack = 0;",
    "",
    "\tyy_current_buffer = 0;",
    "",
    "#ifdef YY_USES_REJECT",
    "\tyy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];",
    "#else",
    "\tyy_state_buf = 0;",
    "#endif",
    "}",
    "",
    "yyFlexLexer::~yyFlexLexer()",
    "{",
    "\tdelete yy_state_buf;",
    "\tyy_delete_buffer(yy_current_buffer);",
    "}",
    "",
    "void yyFlexLexer::switch_streams(std::istream* new_in, std::ostream* new_out)",
    "{",
    "\tif (new_in) {",
    "\t\tyy_delete_buffer(yy_current_buffer);",
    "\t\tyy_switch_to_buffer(yy_create_buffer(new_in, YY_BUF_SIZE));",
    "\t}",
    "",
    "\tif (new_out)",
    "\t\tyyout = new_out;",
    "}",
    "",
    "#ifdef YY_INTERACTIVE",
    "int yyFlexLexer::LexerInput(char* buf, int /* max_size */)",
    "#else",
    "int yyFlexLexer::LexerInput(char* buf, int max_size)",
    "#endif",
    "{",
    "\tif (yyin->eof() || yyin->fail())",
    "\t\treturn 0;",
    "",
    "#ifdef YY_INTERACTIVE",
    "\tyyin->get(buf[0]);",
    "",
    "\tif (yyin->eof())",
    "\t\treturn 0;",
    "",
    "\tif (yyin->bad())",
    "\t\treturn -1;",
    "",
    "\treturn 1;",
    "",
    "#else",
    "\t(void) yyin->read(buf, max_size);",
    "",
    "\tif (yyin->bad())",
    "\t\treturn -1;",
    "\telse",
    "\t\treturn yyin->gcount();",
    "#endif",
    "}",
    "",
    "void yyFlexLexer::LexerOutput(const char* buf, int size)",
    "{",
    "\t(void) yyout->write(buf, size);",
    "}",
    "%*",
    "",
    "/* yy_get_next_buffer - try to read in a new buffer",
    " *",
    " * Returns a code representing an action:",
    " *\tEOB_ACT_LAST_MATCH -",
    " *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position",
    " *\tEOB_ACT_END_OF_FILE - end of file",
    " */",
    "%-",
    "static int",
    "yy_get_next_buffer(void)",
    "%+",
    "int yyFlexLexer::yy_get_next_buffer()",
    "%*",
    "{",
    "\tchar *dest = yy_current_buffer->yy_ch_buf;",
    "\tchar *source = yytext_ptr;",
    "\tint number_to_move, i;",
    "\tint ret_val;",
    "",
    "\tif (yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1])",
    "\t\tYY_FATAL_ERROR(\"fatal flex scanner internal error--end of buffer missed\");",
    "",
    "\tif (yy_current_buffer->yy_fill_buffer == 0) {",
    "\t\t/* Don't try to fill the buffer, so this is an EOF. */",
    "\t\tif (yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1) {",
    "\t\t\t/* We matched a single character, the EOB, so",
    "\t\t\t * treat this as a final EOF.",
    "\t\t\t */",
    "\t\t\treturn EOB_ACT_END_OF_FILE;",
    "\t\t} else {",
    "\t\t\t/* We matched some text prior to the EOB, first",
    "\t\t\t * process it.",
    "\t\t\t */",
    "\t\t\treturn EOB_ACT_LAST_MATCH;",
    "\t\t}",
    "\t}",
    "",
    "\t/* Try to read more data. */",
    "",
    "\t/* First move last chars to start of buffer. */",
    "\tnumber_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;",
    "",
    "\tfor (i = 0; i < number_to_move; ++i)",
    "\t\t*(dest++) = *(source++);",
    "",
    "\tif (yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING)",
    "\t\t/* don't do the read, it's not guaranteed to return an EOF,",
    "\t\t * just force an EOF",
    "\t\t */",
    "\t\tyy_current_buffer->yy_n_chars = yy_n_chars = 0;",
    "",
    "\telse {",
    "\t\tint num_to_read = (int) ((long) yy_current_buffer->yy_buf_size - (long) number_to_move - 1);",
    "",
    "\t\twhile (num_to_read <= 0) {",
    "\t\t\t/* Not enough room in the buffer - grow it. */",
    "#ifdef YY_USES_REJECT",
    "\t\t\tYY_FATAL_ERROR(\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\");",
    "#else",
    "",
    "\t\t\t/* just a shorter name for the current buffer */",
    "\t\t\tYY_BUFFER_STATE b = yy_current_buffer;",
    "",
    "\t\t\tint yy_c_buf_p_offset = (int) (yy_c_buf_p - b->yy_ch_buf);",
    "",
    "\t\t\tif (b->yy_is_our_buffer) {",
    "\t\t\t\tint new_size = (int) (b->yy_buf_size * 2);",
    "",
    "\t\t\t\tif (new_size <= 0)",
    "\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;",
    "\t\t\t\telse",
    "\t\t\t\t\tb->yy_buf_size *= 2;",
    "",
    "\t\t\t\tb->yy_ch_buf = (char *)",
    "\t\t\t\t/* Include room in for 2 EOB chars. */",
    "\t\t\t\t    yy_flex_realloc((void *) b->yy_ch_buf,",
    "\t\t\t\t                    b->yy_buf_size + 2);",
    "\t\t\t} else",
    "\t\t\t\t/* Can't grow it, we don't own it. */",
    "\t\t\t\tb->yy_ch_buf = 0;",
    "",
    "\t\t\tif (!b->yy_ch_buf)",
    "\t\t\t\tYY_FATAL_ERROR(\"fatal error - scanner input buffer overflow\");",
    "",
    "\t\t\tyy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];",
    "",
    "\t\t\tnum_to_read = (int) ((long) yy_current_buffer->yy_buf_size - (long) number_to_move - 1);",
    "#endif",
    "\t\t}",
    "",
    "\t\tif (num_to_read > YY_READ_BUF_SIZE)",
    "\t\t\tnum_to_read = YY_READ_BUF_SIZE;",
    "",
    "\t\t/* Read in more data. */",
    "\t\tYY_INPUT((&yy_current_buffer->yy_ch_buf[number_to_move]),",
    "\t\t         yy_n_chars, num_to_read);",
    "",
    "\t\tyy_current_buffer->yy_n_chars = yy_n_chars;",
    "\t}",
    "",
    "\tif (yy_n_chars == 0) {",
    "\t\tif (number_to_move == YY_MORE_ADJ) {",
    "\t\t\tret_val = EOB_ACT_END_OF_FILE;",
    "\t\t\tyyrestart(yyin);",
    "\t\t} else {",
    "\t\t\tret_val = EOB_ACT_LAST_MATCH;",
    "\t\t\tyy_current_buffer->yy_buffer_status =",
    "\t\t\t\tYY_BUFFER_EOF_PENDING;",
    "\t\t}",
    "\t} else",
    "\t\tret_val = EOB_ACT_CONTINUE_SCAN;",
    "",
    "\tyy_n_chars += number_to_move;",
    "\tyy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;",
    "\tyy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;",
    "",
    "\tyytext_ptr = &yy_current_buffer->yy_ch_buf[0];",
    "",
    "\treturn ret_val;",
    "}",
    "",
    "/* yy_get_previous_state - get the state just before the EOB char was reached */",
    "",
    "%-",
    "static yy_state_type",
    "yy_get_previous_state(void)",
    "%+",
    "yy_state_type yyFlexLexer::yy_get_previous_state()",
    "%*",
    "{",
    "\tyy_state_type yy_current_state;",
    "\tchar *yy_cp;",
    "",
    /*-----------------------------------------------------------------------*/
    "%% code to get the start state into yy_current_state goes here",
    "",
    "\tfor (yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp) {",
    /*-----------------------------------------------------------------------*/
    "%% code to find the next state goes here",
    "\t}",
    "",
    "\treturn yy_current_state;",
    "}",
    "",
    "/* yy_try_NUL_trans - try to make a transition on the NUL character",
    " *",
    " * synopsis",
    " *\tnext_state = yy_try_NUL_trans(current_state);",
    " */",
    "",
    "%-",
    "static yy_state_type",
    "yy_try_NUL_trans(yy_state_type yy_current_state)",
    "%+",
    "yy_state_type yyFlexLexer::yy_try_NUL_trans(yy_state_type yy_current_state)",
    "%*",
    "{",
    "\tint yy_is_jam;",
    /*-----------------------------------------------------------------------*/
    "%% code to find the next state, and perhaps do backing up, goes here",
    "",
    "\treturn yy_is_jam ? 0 : yy_current_state;",
    "}",
    "",
    "%-",
    "#ifndef YY_NO_UNPUT",
    "static void",
    "yyunput(int c, char *yy_bp)",
    "%+",
    "void yyFlexLexer::yyunput(int c, char* yy_bp)",
    "%*",
    "{",
    "\tchar *yy_cp = yy_c_buf_p;",
    "",
    "\t/* undo effects of setting up yytext */",
    "\t*yy_cp = yy_hold_char;",
    "",
    "\tif (yy_cp < yy_current_buffer->yy_ch_buf + 2) {",
    "\t\t/* need to shift things up to make room */",
    "\t\t/* +2 for EOB chars. */",
    "\t\tint number_to_move = yy_n_chars + 2;",
    "\t\tchar *dest = &(yy_current_buffer->yy_ch_buf",
    "\t\t                        [yy_current_buffer->yy_buf_size + 2]);",
    "\t\tchar *source = &yy_current_buffer->yy_ch_buf[number_to_move];",
    "",
    "\t\twhile (source > yy_current_buffer->yy_ch_buf)",
    "\t\t\t*--dest = *--source;",
    "",
    "\t\tyy_cp += (int) (dest - source);",
    "\t\tyy_bp += (int) (dest - source);",
    "\t\tyy_current_buffer->yy_n_chars =",
    "\t\t\tyy_n_chars = (int) yy_current_buffer->yy_buf_size;",
    "",
    "\t\tif (yy_cp < yy_current_buffer->yy_ch_buf + 2)",
    "\t\t\tYY_FATAL_ERROR(\"flex scanner push-back overflow\");",
    "\t}",
    "",
    "\t*--yy_cp = (char) c;",
    /*-----------------------------------------------------------------------*/
    "%% update yylineno here",
    "",
    "\tyytext_ptr = yy_bp;",
    "\tyy_hold_char = *yy_cp;",
    "\tyy_c_buf_p = yy_cp;",
    "}",
    "%-",
    "#endif /* ifndef YY_NO_UNPUT */",
    "%*",
    "",
    "%-",
    "#ifndef YY_NO_INPUT",
    "#ifdef __cplusplus",
    "static int",
    "yyinput()",
    "#else",
    "static int",
    "input(void)",
    "#endif",
    "%+",
    "int yyFlexLexer::yyinput()",
    "%*",
    "{",
    "\tint c;",
    "",
    "\t*yy_c_buf_p = yy_hold_char;",
    "",
    "\tif (*yy_c_buf_p == YY_END_OF_BUFFER_CHAR) {",
    "\t\t/* yy_c_buf_p now points to the character we want to return.",
    "\t\t * If this occurs *before* the EOB characters, then it's a",
    "\t\t * valid NUL; if not, then we've hit the end of the buffer.",
    "\t\t */",
    "\t\tif (yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars])",
    "\t\t\t/* This was really a NUL. */",
    "\t\t\t*yy_c_buf_p = '\\0';",
    "",
    "\t\telse {\t\t\t/* need more input */",
    "\t\t\tint offset = (int) (yy_c_buf_p - yytext_ptr);",
    "\t\t\t++yy_c_buf_p;",
    "",
    "\t\t\tswitch (yy_get_next_buffer()) {",
    "\t\t\tcase EOB_ACT_LAST_MATCH:",
    "\t\t\t\t/* This happens because yy_g_n_b()",
    "\t\t\t\t * sees that we've accumulated a",
    "\t\t\t\t * token and flags that we need to",
    "\t\t\t\t * try matching the token before",
    "\t\t\t\t * proceeding.  But for input(),",
    "\t\t\t\t * there's no matching to consider.",
    "\t\t\t\t * So convert the EOB_ACT_LAST_MATCH",
    "\t\t\t\t * to EOB_ACT_END_OF_FILE.",
    "\t\t\t\t */",
    "",
    "\t\t\t\t/* Reset buffer status. */",
    "\t\t\t\tyyrestart(yyin);",
    "",
    "\t\t\t\t/* fall through */",
    "",
    "\t\t\tcase EOB_ACT_END_OF_FILE:",
    "\t\t\t\t{",
    "\t\t\t\t\tif (yywrap())",
    "\t\t\t\t\t\treturn EOF;",
    "",
    "\t\t\t\t\tif (!yy_did_buffer_switch_on_eof)",
    "\t\t\t\t\t\tYY_NEW_FILE;",
    "#ifdef __cplusplus",
    "\t\t\t\t\treturn yyinput();",
    "#else",
    "\t\t\t\t\treturn input();",
    "#endif",
    "\t\t\t\t}",
    "",
    "\t\t\tcase EOB_ACT_CONTINUE_SCAN:",
    "\t\t\t\tyy_c_buf_p = yytext_ptr + offset;",
    "\t\t\t\tbreak;",
    "\t\t\t}",
    "\t\t}",
    "\t}",
    "",
    "\tc = *(unsigned char *) yy_c_buf_p;\t/* cast for 8-bit char's */",
    "\t*yy_c_buf_p = '\\0';\t\t/* preserve yytext */",
    "\tyy_hold_char = *++yy_c_buf_p;",
    "",
    /*-----------------------------------------------------------------------*/
    "%% update BOL and yylineno",
    "",
    "\treturn c;",
    "}",
    "%-",
    "#endif /* ifndef YY_NO_INPUT */",
    "%*",
    "",
    "%-",
    "void",
    "yyrestart(FILE *input_file)",
    "%+",
    "void yyFlexLexer::yyrestart(std::istream* input_file)",
    "%*",
    "{",
    "\tif (!yy_current_buffer)",
    "\t\tyy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE);",
    "",
    "\tyy_init_buffer(yy_current_buffer, input_file);",
    "\tyy_load_buffer_state();",
    "}",
    "",
    "%-",
    "void",
    "yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)",
    "%+",
    "void yyFlexLexer::yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)",
    "%*",
    "{",
    "\tif (yy_current_buffer == new_buffer)",
    "\t\treturn;",
    "",
    "\tif (yy_current_buffer) {",
    "\t\t/* Flush out information for old buffer. */",
    "\t\t*yy_c_buf_p = yy_hold_char;",
    "\t\tyy_current_buffer->yy_buf_pos = yy_c_buf_p;",
    "\t\tyy_current_buffer->yy_n_chars = yy_n_chars;",
    "\t}",
    "",
    "\tyy_current_buffer = new_buffer;",
    "\tyy_load_buffer_state();",
    "",
    "\t/* We don't actually know whether we did this switch during",
    "\t * EOF (yywrap()) processing, but the only time this flag",
    "\t * is looked at is after yywrap() is called, so it's safe",
    "\t * to go ahead and always set it.",
    "\t */",
    "\tyy_did_buffer_switch_on_eof = 1;",
    "}",
    "",
    "%-",
    "void",
    "yy_load_buffer_state(void)",
    "%+",
    "void yyFlexLexer::yy_load_buffer_state()",
    "%*",
    "{",
    "\tyy_n_chars = yy_current_buffer->yy_n_chars;",
    "\tyytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;",
    "\tyyin = yy_current_buffer->yy_input_file;",
    "\tyy_hold_char = *yy_c_buf_p;",
    "}",
    "",
    "%-",
    "YY_BUFFER_STATE",
    "yy_create_buffer(FILE *file, int size)",
    "%+",
    "YY_BUFFER_STATE yyFlexLexer::yy_create_buffer(std::istream* file, int size)",
    "%*",
    "{",
    "\tYY_BUFFER_STATE b;",
    "",
    "\tb = (YY_BUFFER_STATE) yy_flex_alloc(sizeof(struct yy_buffer_state));",
    "\tif (!b)",
    "\t\tYY_FATAL_ERROR(\"out of dynamic memory in yy_create_buffer()\");",
    "",
    "\tb->yy_buf_size = (yy_size_t) size;",
    "",
    "\t/* yy_ch_buf has to be 2 characters longer than the size given because",
    "\t * we need to put in 2 end-of-buffer characters.",
    "\t */",
    "\tb->yy_ch_buf = (char *) yy_flex_alloc(b->yy_buf_size + 2);",
    "\tif (!b->yy_ch_buf)",
    "\t\tYY_FATAL_ERROR(\"out of dynamic memory in yy_create_buffer()\");",
    "",
    "\tb->yy_is_our_buffer = 1;",
    "",
    "\tyy_init_buffer(b, file);",
    "",
    "\treturn b;",
    "}",
    "",
    "%-",
    "void",
    "yy_delete_buffer(YY_BUFFER_STATE b)",
    "%+",
    "void yyFlexLexer::yy_delete_buffer(YY_BUFFER_STATE b)",
    "%*",
    "{",
    "\tif (!b)",
    "\t\treturn;",
    "",
    "\tif (b == yy_current_buffer)",
    "\t\tyy_current_buffer = (YY_BUFFER_STATE) 0;",
    "",
    "\tif (b->yy_is_our_buffer)",
    "\t\tyy_flex_free((void *) b->yy_ch_buf);",
    "",
    "\tyy_flex_free((void *) b);",
    "}",
    "",
    "%-",
    "void",
    "yy_init_buffer(YY_BUFFER_STATE b, FILE *file)",
    "%+",
    "void yyFlexLexer::yy_init_buffer(YY_BUFFER_STATE b, std::istream* file)",
    "%*",
    "{",
    "\tyy_flush_buffer(b);",
    "",
    "\tb->yy_input_file = file;",
    "\tb->yy_fill_buffer = 1;",
    "",
    "%-",
    "#if YY_ALWAYS_INTERACTIVE",
    "\tb->yy_is_interactive = 1;",
    "#else",
    "#if YY_NEVER_INTERACTIVE",
    "\tb->yy_is_interactive = 0;",
    "#else",
    "\tb->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;",
    "#endif",
    "#endif",
    "%+",
    "\tb->yy_is_interactive = 0;",
    "%*",
    "}",
    "",
    "%-",
    "void",
    "yy_flush_buffer(YY_BUFFER_STATE b)",
    "%+",
    "void yyFlexLexer::yy_flush_buffer(YY_BUFFER_STATE b)",
    "%*",
    "{",
    "\tif (!b)",
    "\t\treturn;",
    "",
    "\tb->yy_n_chars = 0;",
    "",
    "\t/* We always need two end-of-buffer characters.  The first causes",
    "\t * a transition to the end-of-buffer state.  The second causes",
    "\t * a jam in that state.",
    "\t */",
    "\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;",
    "\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
    "",
    "\tb->yy_buf_pos = &b->yy_ch_buf[0];",
    "",
    "\tb->yy_at_bol = 1;",
    "\tb->yy_buffer_status = YY_BUFFER_NEW;",
    "",
    "\tif (b == yy_current_buffer)",
    "\t\tyy_load_buffer_state();",
    "}",
    "%*",
    "",
    "#ifndef YY_NO_SCAN_BUFFER",
    "%-",
    "YY_BUFFER_STATE",
    "yy_scan_buffer(char *bbase, yy_size_t size)",
    "{",
    "\tYY_BUFFER_STATE b;",
    "",
    "\tif (size < 2 ||",
    "\t    bbase[size - 2] != YY_END_OF_BUFFER_CHAR ||",
    "\t    bbase[size - 1] != YY_END_OF_BUFFER_CHAR)",
    "\t    /* They forgot to leave room for the EOB's. */",
    "\t\treturn 0;",
    "",
    "\tb = (YY_BUFFER_STATE) yy_flex_alloc(sizeof(struct yy_buffer_state));",
    "\tif (!b)",
    "\t\tYY_FATAL_ERROR(\"out of dynamic memory in yy_scan_buffer()\");",
    "",
    "\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */",
    "\tb->yy_buf_pos = b->yy_ch_buf = bbase;",
    "\tb->yy_is_our_buffer = 0;",
    "\tb->yy_input_file = 0;",
    "\tb->yy_n_chars = (int) b->yy_buf_size;",
    "\tb->yy_is_interactive = 0;",
    "\tb->yy_at_bol = 1;",
    "\tb->yy_fill_buffer = 0;",
    "\tb->yy_buffer_status = YY_BUFFER_NEW;",
    "",
    "\tyy_switch_to_buffer(b);",
    "",
    "\treturn b;",
    "}",
    "%*",
    "#endif",
    "",
    "#ifndef YY_NO_SCAN_STRING",
    "%-",
    "YY_BUFFER_STATE",
    "yy_scan_string(yyconst char *yy_str)",
    "{",
    "\tint len;",
    "\tfor (len = 0; yy_str[len]; ++len) {",
    "\t\t;",
    "\t}",
    "",
    "\treturn yy_scan_bytes(yy_str, len);",
    "}",
    "%*",
    "#endif",
    "",
    "#ifndef YY_NO_SCAN_BYTES",
    "%-",
    "YY_BUFFER_STATE",
    "yy_scan_bytes(yyconst char *bytes, int len)",
    "{",
    "\tYY_BUFFER_STATE b;",
    "\tchar *buf;",
    "\tyy_size_t n;",
    "\tint i;",
    "",
    "\t/* Get memory for full buffer, including space for trailing EOB's. */",
    "\tn = (yy_size_t) (len + 2);",
    "\tbuf = (char *) yy_flex_alloc(n);",
    "\tif (!buf)",
    "\t\tYY_FATAL_ERROR(\"out of dynamic memory in yy_scan_bytes()\");",
    "",
    "\tfor (i = 0; i < len; ++i)",
    "\t\tbuf[i] = bytes[i];",
    "",
    "\tbuf[len] = buf[len + 1] = YY_END_OF_BUFFER_CHAR;",
    "",
    "\tb = yy_scan_buffer(buf, n);",
    "\tif (!b)",
    "\t\tYY_FATAL_ERROR(\"bad buffer in yy_scan_bytes()\");",
    "",
    "\t/* It's okay to grow etc. this buffer, and we should throw it",
    "\t * away when we're done.",
    "\t */",
    "\tb->yy_is_our_buffer = 1;",
    "",
    "\treturn b;",
    "}",
    "%*",
    "#endif",
    "",
    "#ifndef YY_NO_PUSH_STATE",
    "%-",
    "static void",
    "yy_push_state(int new_state)",
    "%+",
    "void yyFlexLexer::yy_push_state(int new_state)",
    "%*",
    "{",
    "\tif (yy_start_stack_ptr >= yy_start_stack_depth) {",
    "\t\tyy_size_t new_size;",
    "",
    "\t\tyy_start_stack_depth += YY_START_STACK_INCR;",
    "\t\tnew_size = (yy_size_t) yy_start_stack_depth * sizeof(int);",
    "",
    "\t\tif (!yy_start_stack)",
    "\t\t\tyy_start_stack = (int *) yy_flex_alloc(new_size);",
    "",
    "\t\telse",
    "\t\t\tyy_start_stack = (int *) yy_flex_realloc((void *) yy_start_stack,",
    "\t\t\t                                         new_size);",
    "",
    "\t\tif (!yy_start_stack)",
    "\t\t\tYY_FATAL_ERROR(\"out of memory expanding start-condition stack\");",
    "\t}",
    "",
    "\tyy_start_stack[yy_start_stack_ptr++] = YY_START;",
    "",
    "\tBEGIN(new_state);",
    "}",
    "#endif",
    "",
    "#ifndef YY_NO_POP_STATE",
    "%-",
    "static void",
    "yy_pop_state(void)",
    "%+",
    "void yyFlexLexer::yy_pop_state()",
    "%*",
    "{",
    "\tif (--yy_start_stack_ptr < 0)",
    "\t\tYY_FATAL_ERROR(\"start-condition stack underflow\");",
    "",
    "\tBEGIN(yy_start_stack[yy_start_stack_ptr]);",
    "}",
    "#endif",
    "",
    "#ifndef YY_NO_TOP_STATE",
    "%-",
    "static int",
    "yy_top_state(void)",
    "%+",
    "int yyFlexLexer::yy_top_state()",
    "%*",
    "{",
    "\treturn yy_start_stack[yy_start_stack_ptr - 1];",
    "}",
    "#endif",
    "",
    "/* Redefine yyless() so it works in section 3 code. */",
    "",
    "#undef yyless",
    "#define yyless(n) \\",
    "\t\tdo \\",
    "\t\t\t{ \\",
    "\t\t\t\t/* Undo effects of setting up yytext. */ \\",
    "\t\t\t\tyytext[yyleng] = yy_hold_char; \\",
    "\t\t\t\tyy_c_buf_p = yytext + n; \\",
    "\t\t\t\tyy_hold_char = *yy_c_buf_p; \\",
    "\t\t\t\t*yy_c_buf_p = '\\0'; \\",
    "\t\t\t\tyyleng = n; \\",
    "\t\t\t} \\",
    "\t\twhile (0)",
    "",
    "/* Internal utility routines. */",
    "",
    "#ifndef yytext_ptr",
    "static void",
    "yy_flex_strncpy(char *s1, yyconst char *s2, int n)",
    "{",
    "\tint i;",
    "\tfor (i = 0; i < n; ++i)",
    "\t\ts1[i] = s2[i];",
    "}",
    "#endif",
    "",
    "#ifdef YY_NEED_STRLEN",
    "static int",
    "yy_flex_strlen(yyconst char *s)",
    "{",
    "\tint n;",
    "\tfor (n = 0; s[n]; ++n) {",
    "\t\t;",
    "\t}",
    "",
    "\treturn n;",
    "}",
    "#endif",
    "",
    "static void *",
    "yy_flex_alloc(yy_size_t size)",
    "{",
    "\treturn (void *) malloc(size);",
    "}",
    "",
    "static void *",
    "yy_flex_realloc(void *ptr, yy_size_t size)",
    "{",
    "\t/* The cast to (char *) in the following accommodates both",
    "\t * implementations that use char* generic pointers, and those",
    "\t * that use void* generic pointers.  It works with the latter",
    "\t * because both ANSI C and C++ allow castless assignment from",
    "\t * any pointer type to void*, and deal with argument conversions",
    "\t * as though doing an assignment.",
    "\t */",
    "\treturn (void *) realloc((char *) ptr, size);",
    "}",
    "",
    "static void",
    "yy_flex_free(void *ptr)",
    "{",
    "\tfree(ptr);",
    "}",
    "",
    "#if YY_MAIN",
    "int",
    "main(void)",
    "{",
    "\tyylex();",
    "\treturn 0;",
    "}",
    "#endif",
    0
};
